package github

import (
	"context"
	"fmt"
	"io"
	"os/exec"
	"strings"

	"github.com/qiniu/codeagent/internal/code"
	"github.com/qiniu/codeagent/internal/config"
	"github.com/qiniu/codeagent/pkg/models"

	"github.com/google/go-github/v58/github"
	"github.com/qiniu/x/log"
	"golang.org/x/oauth2"
)

type Client struct {
	client *github.Client
	config *config.Config
}

func NewClient(cfg *config.Config) (*Client, error) {
	if cfg.GitHub.Token == "" {
		return nil, fmt.Errorf("GitHub token is required")
	}

	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: cfg.GitHub.Token},
	)
	tc := oauth2.NewClient(context.Background(), ts)
	client := github.NewClient(tc)

	return &Client{
		client: client,
		config: cfg,
	}, nil
}

// CreateBranch creates branch locally and pushes to remote
func (c *Client) CreateBranch(workspace *models.Workspace) error {
	log.Infof("Creating branch for workspace: %s, path: %s", workspace.Branch, workspace.Path)

	// Check Git configuration
	c.checkGitConfig(workspace.Path)

	// Create an empty "Initial plan" commit, mimicking Copilot's behavior
	// This allows immediate branch and PR establishment, providing better user experience
	initialCommitMsg := fmt.Sprintf("Initial plan for Issue #%d: %s",
		workspace.Issue.GetNumber(),
		workspace.Issue.GetTitle())

	// Use git commit --allow-empty to create empty commit
	cmd := exec.Command("git", "commit", "--allow-empty", "-m", initialCommitMsg)
	cmd.Dir = workspace.Path
	commitOutput, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to create initial empty commit: %w\nCommand output: %s", err, string(commitOutput))
	}

	// Check current branch status
	cmd = exec.Command("git", "status")
	cmd.Dir = workspace.Path
	statusOutput, err := cmd.CombinedOutput()
	if err != nil {
		log.Warnf("Failed to check git status: %v", err)
	} else {
		log.Infof("Git status:\n%s", string(statusOutput))
	}

	// Push branch to remote
	cmd = exec.Command("git", "push", "-u", "origin", workspace.Branch)
	cmd.Dir = workspace.Path

	// Capture command output and error
	pushOutput, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to push branch: %w\nCommand output: %s", err, string(pushOutput))
	}

	log.Infof("Created and pushed branch: %s", workspace.Branch)
	return nil
}

// checkGitConfig checks Git configuration
func (c *Client) checkGitConfig(workspacePath string) {
	log.Infof("Checking Git configuration for workspace: %s", workspacePath)

	// Check Git user configuration
	cmd := exec.Command("git", "config", "user.name")
	cmd.Dir = workspacePath
	nameOutput, err := cmd.Output()
	if err != nil {
		log.Warnf("Failed to get git user.name: %v", err)
	} else {
		log.Infof("Git user.name: %s", strings.TrimSpace(string(nameOutput)))
	}

	cmd = exec.Command("git", "config", "user.email")
	cmd.Dir = workspacePath
	emailOutput, err := cmd.Output()
	if err != nil {
		log.Warnf("Failed to get git user.email: %v", err)
	} else {
		log.Infof("Git user.email: %s", strings.TrimSpace(string(emailOutput)))
	}

	// Check remote repository configuration
	cmd = exec.Command("git", "remote", "-v")
	cmd.Dir = workspacePath
	remoteOutput, err := cmd.Output()
	if err != nil {
		log.Warnf("Failed to get remote configuration: %v", err)
	} else {
		log.Infof("Remote configuration:\n%s", string(remoteOutput))
	}
}

// CreatePullRequest creates Pull Request
func (c *Client) CreatePullRequest(workspace *models.Workspace) (*github.PullRequest, error) {
	// Parse repository information
	repoOwner, repoName := c.parseRepoURL(workspace.Repository)
	if repoOwner == "" || repoName == "" {
		return nil, fmt.Errorf("invalid repository URL: %s", workspace.Repository)
	}

	// Get repository's default branch
	defaultBranch, err := c.getDefaultBranch(repoOwner, repoName)
	if err != nil {
		log.Errorf("Failed to get default branch for %s/%s, using 'main' as fallback: %v", repoOwner, repoName, err)
		defaultBranch = "main"
	}
	log.Infof("Using default branch '%s' for repository %s/%s", defaultBranch, repoOwner, repoName)

	// Create PR
	prTitle := fmt.Sprintf("Implement Issue #%d: %s", workspace.Issue.GetNumber(), workspace.Issue.GetTitle())
	prBody := fmt.Sprintf(`## Implementation Plan

This PR is automatically generated by Code Agent to implement Issue #%d.

### Issue Description
%s

### Implementation Plan
- [ ] Analyze requirements and formulate implementation plan
- [ ] Write core code
- [ ] Add test cases
- [ ] Code review and optimization

---
*This PR is automatically created by Code Agent(https://github.com/qiniu/codeagent) and will be progressively improved*`,
		workspace.Issue.GetNumber(),
		workspace.Issue.GetBody())

	newPR := &github.NewPullRequest{
		Title: &prTitle,
		Body:  &prBody,
		Head:  &workspace.Branch,
		Base:  &defaultBranch,
	}

	pr, _, err := c.client.PullRequests.Create(context.Background(), repoOwner, repoName, newPR)
	if err != nil {
		return nil, fmt.Errorf("failed to create PR: %w", err)
	}

	log.Infof("Created PR: %s", pr.GetHTMLURL())
	return pr, nil
}

// getDefaultBranch gets repository's default branch
func (c *Client) getDefaultBranch(owner, repo string) (string, error) {
	repository, _, err := c.client.Repositories.Get(context.Background(), owner, repo)
	if err != nil {
		return "", fmt.Errorf("failed to get repository info: %w", err)
	}

	defaultBranch := repository.GetDefaultBranch()
	if defaultBranch == "" {
		return "", fmt.Errorf("repository has no default branch")
	}

	return defaultBranch, nil
}

// CommitAndPush detects file changes and commits and pushes
func (c *Client) CommitAndPush(workspace *models.Workspace, result *models.ExecutionResult, codeClient code.Code) error {
	// Check if there are file changes
	cmd := exec.Command("git", "status", "--porcelain")
	cmd.Dir = workspace.Path
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to check git status: %w", err)
	}

	if strings.TrimSpace(string(output)) == "" {
		log.Infof("No changes detected in workspace")
		return nil
	}

	// Add all changes
	cmd = exec.Command("git", "add", ".")
	cmd.Dir = workspace.Path
	addOutput, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to add changes: %w\nCommand output: %s", err, string(addOutput))
	}

	// Use AI to generate standard English commit message
	commitMsg, err := c.generateCommitMessage(workspace, result, codeClient)
	if err != nil {
		log.Errorf("Failed to generate commit message with AI, using fallback: %v", err)
		// Use fallback commit message
		summary := extractSummaryFromOutput(result.Output)
		commitMsg = fmt.Sprintf("feat: implement Issue #%d - %s\n\n%s",
			workspace.Issue.GetNumber(),
			workspace.Issue.GetTitle(),
			summary)
	}

	cmd = exec.Command("git", "commit", "-m", commitMsg)
	cmd.Dir = workspace.Path
	commitOutput, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to commit changes: %w\nCommand output: %s", err, string(commitOutput))
	}

	// Push to remote (with conflict handling)
	cmd = exec.Command("git", "push")
	cmd.Dir = workspace.Path
	pushOutput, err := cmd.CombinedOutput()
	if err != nil {
		pushOutputStr := string(pushOutput)
		log.Infof("Push failed, output: %s", pushOutputStr)

		// Check if it's a push conflict (more lenient detection)
		if strings.Contains(pushOutputStr, "non-fast-forward") {
			log.Infof("Push failed due to remote changes, attempting to resolve conflict")

			// After successful pull, try pushing again
			cmd = exec.Command("git", "push")
			cmd.Dir = workspace.Path
			pushOutput2, err2 := cmd.CombinedOutput()
			if err2 != nil {
				log.Errorf("Push still failed after pull, attempting force push")
				return fmt.Errorf("failed to push changes: %w\nCommand output: %s", err2, string(pushOutput2))
			}

			log.Infof("Successfully pushed changes after pulling remote updates")
			return nil
		}

		return fmt.Errorf("failed to push changes: %w\nCommand output: %s", err, string(pushOutput))
	}

	log.Infof("Committed and pushed changes for Issue #%d", workspace.Issue.GetNumber())
	return nil
}

// PullLatestChanges pulls latest code from remote (preferring rebase strategy)
func (c *Client) PullLatestChanges(workspace *models.Workspace, pr *github.PullRequest) error {
	log.Infof("Pulling latest changes for workspace: %s (PR #%d)", workspace.Path, pr.GetNumber())

	// Get PR's target branch (base branch)
	baseBranch := pr.GetBase().GetRef()
	if baseBranch == "" {
		log.Errorf("PR base branch is empty for PR #%d", pr.GetNumber())
		return fmt.Errorf("PR base branch is empty for PR #%d", pr.GetNumber())
	}

	// Get PR's source branch (head branch)
	headBranch := pr.GetHead().GetRef()
	if headBranch == "" {
		log.Errorf("PR head branch is empty for PR #%d", pr.GetNumber())
		return fmt.Errorf("PR head branch is empty for PR #%d", pr.GetNumber())
	}

	log.Infof("PR #%d: %s -> %s", pr.GetNumber(), headBranch, baseBranch)

	// 1. Get all remote references
	cmd := exec.Command("git", "fetch", "--all", "--prune")
	cmd.Dir = workspace.Path
	fetchOutput, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to fetch latest changes: %w\nCommand output: %s", err, string(fetchOutput))
	}
	log.Infof("Fetched all remote references for PR #%d", pr.GetNumber())

	// 2. Check if there are uncommitted changes
	cmd = exec.Command("git", "status", "--porcelain")
	cmd.Dir = workspace.Path
	statusOutput, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to check git status: %w", err)
	}

	hasChanges := strings.TrimSpace(string(statusOutput)) != ""
	if hasChanges {
		// There are uncommitted changes, stash first
		log.Infof("Found uncommitted changes in worktree, stashing them")
		cmd = exec.Command("git", "stash", "push", "-m", fmt.Sprintf("Auto stash before syncing PR #%d", pr.GetNumber()))
		cmd.Dir = workspace.Path
		stashOutput, err := cmd.CombinedOutput()
		if err != nil {
			log.Warnf("Failed to stash changes: %v, output: %s", err, string(stashOutput))
		}
	}

	// 3. Try to get PR content directly
	prNumber := pr.GetNumber()
	log.Infof("Attempting to fetch PR #%d content directly", prNumber)
	cmd = exec.Command("git", "fetch", "origin", fmt.Sprintf("pull/%d/head", prNumber))
	cmd.Dir = workspace.Path
	fetchOutput, err = cmd.CombinedOutput()
	if err == nil {
		// Direct fetch successful, use rebase to merge updates
		log.Infof("Successfully fetched PR #%d content, attempting rebase", prNumber)
		cmd = exec.Command("git", "rebase", "FETCH_HEAD")
		cmd.Dir = workspace.Path
		rebaseOutput, err := cmd.CombinedOutput()
		if err != nil {
			log.Errorf("Rebase failed, trying reset: %v, output: %s", err, string(rebaseOutput))
			// Rebase failed, force switch to PR content
			cmd = exec.Command("git", "reset", "--hard", "FETCH_HEAD")
			cmd.Dir = workspace.Path
			resetOutput, err := cmd.CombinedOutput()
			if err != nil {
				return fmt.Errorf("failed to reset to PR #%d: %w\nCommand output: %s", prNumber, err, string(resetOutput))
			}
			log.Infof("Hard reset worktree to PR #%d content", prNumber)
		} else {
			log.Infof("Successfully rebased worktree to PR #%d content", prNumber)
		}
	} else {
		// Direct fetch failed, use traditional rebase method
		log.Errorf("Failed to fetch PR #%d directly: %v, falling back to traditional rebase, output: %s", prNumber, err, string(fetchOutput))

		// Try rebasing to latest code of target branch
		cmd = exec.Command("git", "rebase", fmt.Sprintf("origin/%s", baseBranch))
		cmd.Dir = workspace.Path
		rebaseOutput, err := cmd.CombinedOutput()
		if err != nil {
			log.Errorf("Rebase to base branch failed: %v, output: %s", err, string(rebaseOutput))
			// Rebase failed, try force syncing to base branch
			cmd = exec.Command("git", "reset", "--hard", fmt.Sprintf("origin/%s", baseBranch))
			cmd.Dir = workspace.Path
			resetOutput, err := cmd.CombinedOutput()
			if err != nil {
				return fmt.Errorf("failed to reset to base branch %s: %w\nCommand output: %s", baseBranch, err, string(resetOutput))
			}
			log.Infof("Hard reset worktree to base branch %s", baseBranch)
		} else {
			log.Infof("Successfully rebased worktree to base branch %s", baseBranch)
		}
	}

	// 4. If there was stash before, try to restore
	if hasChanges {
		log.Infof("Attempting to restore stashed changes for PR #%d", prNumber)
		cmd = exec.Command("git", "stash", "pop")
		cmd.Dir = workspace.Path
		stashPopOutput, err := cmd.CombinedOutput()
		if err != nil {
			log.Warnf("Failed to restore stashed changes: %v, output: %s", err, string(stashPopOutput))
			log.Infof("You may need to manually resolve the stashed changes later")
		} else {
			log.Infof("Successfully restored stashed changes")
		}
	}

	log.Infof("Successfully pulled latest changes for PR #%d using rebase strategy", pr.GetNumber())
	return nil
}

// GetPullRequest gets complete PR information
func (c *Client) GetPullRequest(owner, repo string, prNumber int) (*github.PullRequest, error) {
	pr, _, err := c.client.PullRequests.Get(context.Background(), owner, repo, prNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to get PR #%d: %w", prNumber, err)
	}
	return pr, nil
}

// CreatePullRequestComment creates comment on PR
func (c *Client) CreatePullRequestComment(pr *github.PullRequest, commentBody string) error {
	prURL := pr.GetHTMLURL()
	log.Infof("Creating comment for PR URL: %s", prURL)

	repoOwner, repoName := c.parseRepoURL(prURL)
	if repoOwner == "" || repoName == "" {
		return fmt.Errorf("invalid repository URL: %s", prURL)
	}

	log.Infof("Parsed repository: %s/%s, PR number: %d", repoOwner, repoName, pr.GetNumber())

	// Use Issue Comments API to create PR comment
	// PR is actually also a type of Issue, so Issue Comments API can be used
	comment := &github.IssueComment{
		Body: &commentBody,
	}

	_, _, err := c.client.Issues.CreateComment(context.Background(), repoOwner, repoName, pr.GetNumber(), comment)
	if err != nil {
		return fmt.Errorf("failed to create PR comment: %w", err)
	}

	log.Infof("Created comment on PR #%d", pr.GetNumber())
	return nil
}

// ReplyToReviewComment replies to PR code line comment
func (c *Client) ReplyToReviewComment(pr *github.PullRequest, commentID int64, commentBody string) error {
	prURL := pr.GetHTMLURL()
	log.Infof("Replying to review comment %d for PR URL: %s", commentID, prURL)

	repoOwner, repoName := c.parseRepoURL(prURL)
	if repoOwner == "" || repoName == "" {
		return fmt.Errorf("invalid repository URL: %s", prURL)
	}

	log.Infof("Parsed repository: %s/%s, PR number: %d, comment ID: %d", repoOwner, repoName, pr.GetNumber(), commentID)

	// Use Pull Request Review Comments API to reply to comment
	_, _, err := c.client.PullRequests.CreateCommentInReplyTo(context.Background(), repoOwner, repoName, pr.GetNumber(), commentBody, commentID)
	if err != nil {
		return fmt.Errorf("failed to reply to review comment: %w", err)
	}

	log.Infof("Replied to review comment %d on PR #%d", commentID, pr.GetNumber())
	return nil
}

// UpdatePullRequest updates PR's Body
func (c *Client) UpdatePullRequest(pr *github.PullRequest, newBody string) error {
	prURL := pr.GetHTMLURL()
	log.Infof("Updating PR body for URL: %s", prURL)

	repoOwner, repoName := c.parseRepoURL(prURL)
	if repoOwner == "" || repoName == "" {
		return fmt.Errorf("invalid repository URL: %s", prURL)
	}

	log.Infof("Parsed repository: %s/%s, PR number: %d", repoOwner, repoName, pr.GetNumber())

	prRequest := &github.PullRequest{Body: &newBody}
	_, _, err := c.client.PullRequests.Edit(context.Background(), repoOwner, repoName, pr.GetNumber(), prRequest)
	if err != nil {
		return fmt.Errorf("failed to update PR body: %w", err)
	}

	log.Infof("Updated PR #%d body", pr.GetNumber())
	return nil
}

// GetReviewComments gets all comments for specified review
func (c *Client) GetReviewComments(pr *github.PullRequest, reviewID int64) ([]*github.PullRequestComment, error) {
	prURL := pr.GetHTMLURL()
	repoOwner, repoName := c.parseRepoURL(prURL)
	if repoOwner == "" || repoName == "" {
		return nil, fmt.Errorf("invalid repository URL: %s", prURL)
	}

	comments, _, err := c.client.PullRequests.ListComments(context.Background(), repoOwner, repoName, pr.GetNumber(), &github.PullRequestListCommentsOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get review comments: %w", err)
	}

	// Filter out comments belonging to specified review
	var reviewComments []*github.PullRequestComment
	for _, comment := range comments {
		if comment.GetPullRequestReviewID() == reviewID {
			reviewComments = append(reviewComments, comment)
		}
	}

	return reviewComments, nil
}

// GetAllPRComments gets all PR comments, including general comments and code line comments
func (c *Client) GetAllPRComments(pr *github.PullRequest) (*models.PRAllComments, error) {
	prURL := pr.GetHTMLURL()
	repoOwner, repoName := c.parseRepoURL(prURL)
	if repoOwner == "" || repoName == "" {
		return nil, fmt.Errorf("invalid repository URL: %s", prURL)
	}

	prNumber := pr.GetNumber()
	log.Infof("Fetching all comments for PR #%d", prNumber)

	// Get general PR comments (Issue Comments)
	issueComments, _, err := c.client.Issues.ListComments(context.Background(), repoOwner, repoName, prNumber, &github.IssueListCommentsOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get PR issue comments: %w", err)
	}

	// Get code line comments (Review Comments)
	reviewComments, _, err := c.client.PullRequests.ListComments(context.Background(), repoOwner, repoName, prNumber, &github.PullRequestListCommentsOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get PR review comments: %w", err)
	}

	// Get all reviews for PR
	reviews, _, err := c.client.PullRequests.ListReviews(context.Background(), repoOwner, repoName, prNumber, &github.ListOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get PR reviews: %w", err)
	}

	log.Infof("Found %d issue comments, %d review comments, %d reviews for PR #%d",
		len(issueComments), len(reviewComments), len(reviews), prNumber)

	return &models.PRAllComments{
		PRBody:         pr.GetBody(),
		IssueComments:  issueComments,
		ReviewComments: reviewComments,
		Reviews:        reviews,
	}, nil
}

// parseRepoURL parses repository URL to get owner and repo name
func (c *Client) parseRepoURL(repoURL string) (owner, repo string) {
	// Handle HTTPS URL: https://github.com/owner/repo.git
	if strings.Contains(repoURL, "github.com") {
		parts := strings.Split(repoURL, "/")
		if len(parts) >= 2 {
			// Handle PR URL: https://github.com/owner/repo/pull/11
			if len(parts) >= 4 && parts[len(parts)-2] == "pull" {
				repo = parts[len(parts)-3]
				owner = parts[len(parts)-4]
			} else {
				// Handle repository URL: https://github.com/owner/repo.git
				repo = strings.TrimSuffix(parts[len(parts)-1], ".git")
				owner = parts[len(parts)-2]
			}
		}
	}
	return owner, repo
}

// extractSummaryFromOutput extracts summary information from AI output
func extractSummaryFromOutput(output string) string {
	lines := strings.Split(output, "\n")

	// Look for changes summary section
	var summaryLines []string
	var inSummarySection bool

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)

		// Detect changes summary section start
		if strings.HasPrefix(trimmedLine, models.SectionSummary) {
			inSummarySection = true
			continue
		}

		// Detect other section start, end summary section
		if inSummarySection && strings.HasPrefix(trimmedLine, "## ") {
			break
		}

		// Collect summary content
		if inSummarySection && trimmedLine != "" {
			summaryLines = append(summaryLines, line)
		}
	}

	summary := strings.TrimSpace(strings.Join(summaryLines, "\n"))

	// If no summary found, return first few lines as fallback
	if summary == "" && len(lines) > 0 {
		// Take first 3 non-empty lines
		var fallbackLines []string
		for _, line := range lines[:min(3, len(lines))] {
			if strings.TrimSpace(line) != "" {
				fallbackLines = append(fallbackLines, strings.TrimSpace(line))
			}
		}
		summary = strings.Join(fallbackLines, "\n")
	}

	return summary
}

// generateCommitMessage uses AI to generate standard English commit message
func (c *Client) generateCommitMessage(workspace *models.Workspace, result *models.ExecutionResult, codeClient code.Code) (string, error) {
	// Get git status and diff information
	cmd := exec.Command("git", "status", "--porcelain")
	cmd.Dir = workspace.Path
	statusOutput, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get git status: %w", err)
	}

	cmd = exec.Command("git", "diff", "--cached")
	cmd.Dir = workspace.Path
	diffOutput, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get git diff: %w", err)
	}

	// Build more detailed prompt
	prompt := fmt.Sprintf(`Please help me generate a standard English commit message that follows open source community conventions.

Issue Information:
- Title: %s
- Description: %s

AI Execution Result:
%s

Git Status:
%s

Git Changes:
%s

Please follow this format for the commit message:
1. Use conventional commits format (e.g., feat:, fix:, docs:, style:, refactor:, test:, chore:)
2. Keep the title concise and clear, no more than 50 characters
3. If necessary, add detailed description after an empty line
4. Finally add "Closes #%d" to link the Issue

Important: Please return only the plain text commit message content, do not include any formatting marks (such as markdown syntax, etc.), and do not include any explanatory text.`,
		workspace.Issue.GetTitle(),
		workspace.Issue.GetBody(),
		result.Output,
		string(statusOutput),
		string(diffOutput),
		workspace.Issue.GetNumber(),
	)

	// Call AI to generate commit message
	resp, err := codeClient.Prompt(prompt)
	if err != nil {
		return "", fmt.Errorf("failed to generate commit message: %w", err)
	}

	// Read AI output
	output, err := io.ReadAll(resp.Out)
	if err != nil {
		return "", fmt.Errorf("failed to read AI output: %w", err)
	}

	commitMsg := strings.TrimSpace(string(output))

	// Ensure commit message is not empty
	if commitMsg == "" {
		return "", fmt.Errorf("AI generated empty commit message")
	}

	return commitMsg, nil
}

// DeleteCodeAgentBranch deletes branches created by CodeAgent
func (c *Client) DeleteCodeAgentBranch(ctx context.Context, owner, repo, branchName string) error {
	log.Infof("Attempting to delete CodeAgent branch: %s", branchName)

	// Ensure only deleting branches starting with codeagent
	if !strings.HasPrefix(branchName, "codeagent") {
		log.Warnf("Branch %s is not a CodeAgent branch, skipping deletion", branchName)
		return nil
	}

	// Use GitHub API to delete branch
	_, err := c.client.Git.DeleteRef(ctx, owner, repo, fmt.Sprintf("heads/%s", branchName))
	if err != nil {
		// If branch doesn't exist, this is not an error
		if strings.Contains(err.Error(), "404") || strings.Contains(err.Error(), "Reference does not exist") {
			log.Infof("Branch %s does not exist, no deletion needed", branchName)
			return nil
		}
		return fmt.Errorf("failed to delete branch %s: %w", branchName, err)
	}

	log.Infof("Successfully deleted CodeAgent branch: %s", branchName)
	return nil
}

// min returns the smaller of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
