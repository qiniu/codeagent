package context

import (
	"fmt"
	"strings"
	"time"
)

// PRFormatter ä¸“é—¨ç”¨äºæ ¼å¼åŒ–PRæè¿°
// æä¾›ä¼˜é›…ã€ç»“æ„åŒ–çš„PRæè¿°æ ¼å¼
type PRFormatter struct {
	maxDescriptionLength int
}

// NewPRFormatter åˆ›å»ºæ–°çš„PRæ ¼å¼åŒ–å™¨
func NewPRFormatter() *PRFormatter {
	return &PRFormatter{
		maxDescriptionLength: 1000,
	}
}

// FormatPRDescription æ ¼å¼åŒ–PRæè¿°
// æä¾›ç®€æ´ã€æ ¸å¿ƒçš„PRæè¿°
func (f *PRFormatter) FormatPRDescription(
	issueTitle string,
	issueBody string,
	summary string,
	changes string,
	testPlan string,
	aiOutput string,
	issueNumber int,
) string {
	var builder strings.Builder

	// å¤´éƒ¨ä¿¡æ¯
	builder.WriteString(f.formatHeader(issueTitle, issueNumber))
	builder.WriteString("\n\n")

	// ä¿®æ”¹æ€»ç»“ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
	if summary != "" {
		builder.WriteString(f.formatSummary(summary))
		builder.WriteString("\n\n")
	}

	// å˜æ›´è¯¦æƒ…ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
	if changes != "" {
		builder.WriteString(f.formatChanges(changes))
		builder.WriteString("\n\n")
	}

	// æŠ€æœ¯ç»†èŠ‚ï¼ˆå…³é”®å®ç°ç‚¹å’ŒAIè¯¦ç»†åˆ†æï¼‰
	builder.WriteString(f.formatTechnicalDetails(aiOutput))
	builder.WriteString("\n\n")

	// é¡µè„šä¿¡æ¯
	builder.WriteString(f.formatFooter())

	return builder.String()
}

// formatHeader æ ¼å¼åŒ–PRå¤´éƒ¨
func (f *PRFormatter) formatHeader(issueTitle string, issueNumber int) string {
	return fmt.Sprintf(`# ğŸš€ %s

> **Closes #%d** | Auto-generated by CodeAgent ğŸ¤–`, issueTitle, issueNumber)
}

// formatIssueContext æ ¼å¼åŒ–Issueä¸Šä¸‹æ–‡
func (f *PRFormatter) formatIssueContext(title, body string) string {
	var builder strings.Builder

	builder.WriteString("## ğŸ“‹ Original Issue\n\n")
	builder.WriteString(fmt.Sprintf("**Title**: %s\n\n", title))

	if body != "" {
		// æ¸…ç†å’Œæ ¼å¼åŒ–body
		cleanBody := f.cleanIssueBody(body)
		if len(cleanBody) > f.maxDescriptionLength {
			cleanBody = cleanBody[:f.maxDescriptionLength] + "..."
		}
		builder.WriteString("**Description**:\n")
		builder.WriteString(cleanBody)
	}

	return builder.String()
}

// formatSummary æ ¼å¼åŒ–æ‘˜è¦
func (f *PRFormatter) formatSummary(summary string) string {
	return fmt.Sprintf(`## ğŸ¯ Implementation Summary

%s`, f.formatMarkdownSection(summary))
}

// formatChanges æ ¼å¼åŒ–å˜æ›´è¯¦æƒ…
func (f *PRFormatter) formatChanges(changes string) string {
	return fmt.Sprintf(`## ğŸ“ Changes Made

%s`, f.formatMarkdownSection(changes))
}

// formatTestPlan æ ¼å¼åŒ–æµ‹è¯•è®¡åˆ’
func (f *PRFormatter) formatTestPlan(testPlan string) string {
	return fmt.Sprintf(`## ğŸ§ª Testing

%s`, f.formatMarkdownSection(testPlan))
}

// formatTechnicalDetails æ ¼å¼åŒ–æŠ€æœ¯ç»†èŠ‚
func (f *PRFormatter) formatTechnicalDetails(aiOutput string) string {
	// æå–å…³é”®ä¿¡æ¯
	keyPoints := f.extractKeyPoints(aiOutput)

	var builder strings.Builder

	// æ·»åŠ å…³é”®å®ç°ç‚¹ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
	if len(keyPoints) > 0 {
		builder.WriteString("### Key Implementation Points:\n")
		for _, point := range keyPoints {
			builder.WriteString(fmt.Sprintf("- %s\n", point))
		}
		builder.WriteString("\n")
	}

	// æ·»åŠ AIç”Ÿæˆçš„å®Œæ•´åˆ†æä½œä¸ºæŠ˜å å†…å®¹
	builder.WriteString("<details>\n")
	builder.WriteString("<summary><b>ğŸ¤– Full AI Analysis</b></summary>\n\n")
	builder.WriteString("```\n")
	// æˆªæ–­è¿‡é•¿çš„è¾“å‡º
	if len(aiOutput) > 2000 {
		builder.WriteString(aiOutput[:2000] + "... [truncated]")
	} else {
		builder.WriteString(aiOutput)
	}
	builder.WriteString("\n```\n")
	builder.WriteString("</details>")

	return builder.String()
}

// formatFooter æ ¼å¼åŒ–é¡µè„š
func (f *PRFormatter) formatFooter() string {
	return fmt.Sprintf(`---

*This pull request was automatically generated by [CodeAgent](https://github.com/qiniu/codeagent) on %s.*

> ğŸ’¡ **Review Tips**:
> - Focus on code quality and correctness
> - Verify the implementation matches the issue requirements
> - Check for proper error handling and edge cases
> - Ensure tests are comprehensive`, time.Now().Format("2006-01-02 15:04:05"))
}

// formatMarkdownSection æ ¼å¼åŒ–Markdownæ®µè½
func (f *PRFormatter) formatMarkdownSection(content string) string {
	// æ¸…ç†å¤šä½™çš„ç©ºè¡Œå’Œæ ¼å¼
	content = strings.TrimSpace(content)
	content = strings.ReplaceAll(content, "\r\n", "\n")
	content = strings.ReplaceAll(content, "\r", "\n")

	// ç¡®ä¿æ®µè½ä¹‹é—´æœ‰ç©ºè¡Œ
	lines := strings.Split(content, "\n")
	var formattedLines []string

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line != "" {
			formattedLines = append(formattedLines, line)
		}
	}

	return strings.Join(formattedLines, "\n")
}

// cleanIssueBody æ¸…ç†Issueæ­£æ–‡
func (f *PRFormatter) cleanIssueBody(body string) string {
	// ç§»é™¤å‘½ä»¤è¡Œ
	body = strings.ReplaceAll(body, "/code", "")
	body = strings.ReplaceAll(body, "/continue", "")
	body = strings.ReplaceAll(body, "/fix", "")

	// æ¸…ç†å¤šä½™çš„ç©ºæ ¼å’Œç©ºè¡Œ
	body = strings.TrimSpace(body)
	body = strings.ReplaceAll(body, "\r\n", "\n")
	body = strings.ReplaceAll(body, "\r", "\n")

	// ç§»é™¤å¤šä½™çš„ç©ºè¡Œ
	for strings.Contains(body, "\n\n\n") {
		body = strings.ReplaceAll(body, "\n\n\n", "\n\n")
	}

	return body
}

// extractKeyPoints ä»AIè¾“å‡ºä¸­æå–å…³é”®ç‚¹
func (f *PRFormatter) extractKeyPoints(aiOutput string) []string {
	var points []string

	// æŸ¥æ‰¾å¸¸è§çš„å…³é”®ä¿¡æ¯æ¨¡å¼
	patterns := []string{
		"implemented",
		"added",
		"modified",
		"fixed",
		"refactored",
		"created",
		"updated",
		"removed",
		"enhanced",
		"optimized",
		"deleted",
		"changed",
		"improved",
		"simplified",
		"restructured",
	}

	lines := strings.Split(aiOutput, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		lineLower := strings.ToLower(line)

		// è·³è¿‡ç©ºè¡Œå’Œè¿‡çŸ­çš„è¡Œ
		if line == "" || len(line) < 10 {
			continue
		}

		// è·³è¿‡æ˜æ˜¾çš„æ ‡é¢˜è¡Œ
		if strings.HasPrefix(line, "#") || strings.HasPrefix(line, "##") {
			continue
		}

		for _, pattern := range patterns {
			if strings.Contains(lineLower, pattern) && len(line) < 200 {
				// æ¸…ç†è¡Œé¦–çš„ç¬¦å·
				cleanLine := strings.TrimPrefix(line, "- ")
				cleanLine = strings.TrimPrefix(cleanLine, "* ")
				cleanLine = strings.TrimPrefix(cleanLine, "â€¢ ")
				cleanLine = strings.TrimPrefix(cleanLine, "âœ… ")
				cleanLine = strings.TrimPrefix(cleanLine, "1. ")
				cleanLine = strings.TrimPrefix(cleanLine, "2. ")
				cleanLine = strings.TrimPrefix(cleanLine, "3. ")

				if cleanLine != "" && !f.containsPoint(points, cleanLine) {
					points = append(points, cleanLine)
				}
				break
			}
		}
	}

	// é™åˆ¶å…³é”®ç‚¹æ•°é‡
	if len(points) > 6 {
		points = points[:6]
	}

	return points
}

// containsPoint æ£€æŸ¥æ˜¯å¦å·²åŒ…å«ç›¸ä¼¼çš„å…³é”®ç‚¹
func (f *PRFormatter) containsPoint(points []string, newPoint string) bool {
	newPointLower := strings.ToLower(newPoint)
	for _, point := range points {
		if strings.Contains(newPointLower, strings.ToLower(point)) || strings.Contains(strings.ToLower(point), newPointLower) {
			return true
		}
	}
	return false
}

// GenerateSimpleSummary ç”Ÿæˆç®€å•çš„æ‘˜è¦
func (f *PRFormatter) GenerateSimpleSummary(issueTitle string, issueNumber int) string {
	return fmt.Sprintf(`## Summary

This PR implements the requested functionality from Issue #%d: %s

## Changes

- âœ… Implemented the requested feature
- ğŸ“ Added necessary code changes
- ğŸ§ª Ensured proper functionality

## Testing

- [x] Code compiles successfully
- [x] Functionality works as expected
- [x] No breaking changes introduced

---

*Generated by CodeAgent on %s*`,
		issueNumber, issueTitle, time.Now().Format("2006-01-02 15:04:05"))
}
